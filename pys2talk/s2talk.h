///////////////////////////////////////////////////////////////////////////////
//
// s2talk.h
//
// Defines for external talker applications for Spike2 version 7 and later.
//
// Copyright (c) 2010 by Cambridge Electronic Design Ltd. All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////
//
// Started 4/Feb/2010 by TDB
//
#ifndef __S2TALK_H__
#define __S2TALK_H__

///////////////////////////////////////////////////////////////////////////////
//
// General defines
//
///////////////////////////////////////////////////////////////////////////////
//
// The version number of this specification, 
#define TALK_SPEC_VER       1

///////////////////////////////////////////////////////////////////////////////
//
// This is the name of the pipe used by talkers to connect to Spike2 and its
//  buffer size. The talkers themselves don't care about the buffer size.
#define TALK_MASTER_PIPE    "Spike2Talkers"

// This is the base part of the name of pipe used by each talker to communicate
//  with Spike2 (the talker name is appended) and the pipe buffer size. Again,
//  the actual talkers do not need to know about the buffer size.
#define TALK_TALKER_PIPE    "S2Talk_"

////////////////////////////////////////////////////////////////////////////
//
// The size of the buffers for a talker pipe.
#define TALK_TALKER_BSIZE   40000

// We must arrange things so that no packet will be sent that is more than half
//  the talker pipe buffer size - talkers themselves are given information that
//  that limits the packet size so they do not need to know this, but anything
//  that wants to have a packet buffer will need this value.
#define TALK_MAX_PKT  (TALK_TALKER_BSIZE/2)

////////////////////////////////////////////////////////////////////////////
//
// Defines for the length of strings. All of these will be the actual size
//  of the character arrays in question, so the size of the string that can
//  be stored is one less than thse values because of the terminating NULL.
#define TALK_NAME_SZ        12      // The talker name
#define TALK_DESC_SZ        60      // The talker and channel descriptions
#define TALK_CTITL_SZ       12      // Channel suggested title
#define TALK_CUNIT_SZ       8       // Channel suggested units

///////////////////////////////////////////////////////////////////////////////
//
// Talker channel type codes. The types of channel match those used in Spike2
//  pretty closely (as you would expect), the code values start at 1001 so
//  that they are separable from the standard ones used within Spike2.
#define TCT_ADC             1001    // ADC is 16-bit waveform
#define TCT_EVENT           1002    // No rising/falling distinction
#define TCT_MARKER          1003    // Marker data type
#define TCT_ADCMARK         1004    // Adc marker data type
#define TCT_REALMARK        1005    // Real marker data type
#define TCT_TEXTMARK        1006    // Text marker data type
#define TCT_REALWAVE        1007    // RealWave is float waveform
#define TCT_LEVEL           1008    // Level event channel

///////////////////////////////////////////////////////////////////////////////
//
// Talker state codes. You don't have to use these values but it seemed like
//  a good idea to define them so everone could use them. These codes are
//  used by Spike2 and the example talker code produced by CED.
#define TKS_DISCONNECT      0
#define TKS_IDLE            1
#define TKS_ACTIVE          2

///////////////////////////////////////////////////////////////////////////////
//
// Function codes for talker packets. These are used to identify the meaning
//  of a packet and response packets. Response packets have bit 30 set to
//  indicate a response, bit 31 is set as well if it is an error response.
//
// The TKC_EXTRA_TIMEOUT value is used to indicate to Spike2 that an extra 
//  timeout is needed in the wait for the next packet response as the talker
//  is going to be busy for a while. The actual timeout value is 4 bits
//  starting with bit 16 (so 16 to 19 inclusive) and is generated by
//  multiplying TKC_EXTRA_TIMEOUT by the required timeout period in 500
//  millisecond units - from 1 to 15 obviously so 0.5 to 7.5 seconds.
//
#define TKC_TALKERCONNECT   0
#define TKC_GETINFO         1
#define TKC_GETCHAN         2
#define TKC_GETCONFIG       3
#define TKC_SETCONFIG       4
#define TKC_LOCALCONFIG     5
#define TKC_DLGINFO         6
#define TKC_DLGITEM         7
#define TKC_DLGGET          8
#define TKC_DLGSET          9
#define TKC_SAMPLECLEAR     10
#define TKC_ENABLECHAN      11
#define TKC_QUERYREADY      12
#define TKC_SAMPLESTART     13
#define TKC_TALKERCLOSE     14
#define TKC_SAMPLESTOP      15
#define TKC_TALKERIDLE      16
#define TKC_TALKERDATA      17
#define TKC_TALKERPROBLEM   18
#define TKC_SAMPLEKEY       19
#define TKC_TALKERMDATA     20
#define TKC_DRIFTINFO       21

#define TKC_RESPONSE_BIT    0x40000000
#define TKC_ERROR_BIT       0x80000000

#define TKC_EXTRA_TIMEOUT   0x00010000

///////////////////////////////////////////////////////////////////////////////
//
// Error codes, we start these at -800 to avoid other error code values.
// These error codes can be used by a talker in response packets sent to Spike2.
//
#define TKE_BAD_PACKET      -800        // Badly structured packet or read\write failure
#define TKE_BAD_VERSION     -801        // Bad talker version number in connection attempt
#define TKE_BAD_COMMAND     -802        // Unknown command or bad command for mode/talker
#define TKE_BAD_CHAN        -803        // Bad channel number in packet parameters
#define TKE_TIMEOUT         -804        // Communications timeout
#define TKE_NO_CONFIG       -805        // No configuration data available
#define TKE_BAD_CONFIG      -806        // Corrupt or unusable configuration data
#define TKE_FAILURE         -808        // Internal failure in talker - hardware or memory for example
#define TKE_BAD_PARAMS      -807        // Unusable parameter values

///////////////////////////////////////////////////////////////////////////////
//
// Now for definitions of all the structures that are used by talkers. We pack
// these on a 4-byte boundary to keep things clean.
#pragma pack(4)

// The two basic packet definition. This packet structure is used at the start
//  of all the other packets - sometimes with some redefined parameters.
typedef struct TalkPacket
{
    int     nSize;                  // Size of this structure
    int     nCode;                  // Packet function code
    int     nParam1;                // Two integer parameters
    int     nParam2;
    double  dParam1;                // Two double parameters
    double  dParam2;
    char    szParam[256];		    // String parameter data 

    TalkPacket()                    // Constructor ensures memory is zeroed
    {                               //  and the nSize value is correct
        memset(&nSize, 0, sizeof(TalkPacket));
        nSize = sizeof(TalkPacket);
    }
} TalkPacket;


// TalkerInfo holds all of the information about a specific talker. Sent by
//  a talker to Spike2 in response to a GETINFO request, so we can initialise
//  the nCode value automatically as well as nSize.
typedef struct TalkerInfo
{
    int     nSize;                  // Size of this structure
    int     nCode;
    int     nChans;	                // Number of channels (replaces nParam1)
    int     nVer;	                // Talker version number*100 (replaces nParam2)
    double  dParam1;	            // unused, set to zero
    double  dParam2;	            // unused, set to zero
    char    szDesc[256];            // Description of the talker, only 59 chars can be used
    char    szName[TALK_NAME_SZ];   // Talker name - up to 11 chars
    int     nVerComp;               // Earliest version with which we are compatible
    int     nConfigID;              // Unique ID for configuration record or zero
    int     nFlags;                 // Flags indicating talker options
    int     nSpare[32];	            // unused, set to zero

    TalkerInfo()                    // Constructor ensures memory is zeroed
    {                               //  and nSize and nCode values are correct
        memset(&nSize, 0, sizeof(TalkerInfo));
        nSize = sizeof(TalkerInfo);
        nCode = TKC_GETINFO|TKC_RESPONSE_BIT;
    }
} TalkerInfo;

// These are definitions of the talker flag bits - options that apply to the talker
//  as a whole. The flags value is the sum of all required bits.
#define TKF_LOCCONF         0x01    // Talker does local configuration dialog
#define TKF_REMOTE          0x02    // Talker is running remotely from Spike2
#define TKF_SPCONF          0x04    // Talker supports Spike2-based configuration
#define TKF_NODRDB          0x08    // Don't provide the drift debug channel


// The TalkerChanInfo structure holds all of the information about a channel.
// Sent by a talker to Spike2 in response to a GETINFO request, so we can
//  initialise the nCode value automatically as well as nSize.
typedef struct TalkerChanInfo
{
    int     nSize;                  // Size of this structure
    int     nCode;
    int     nChan;                  // Channel number from 0 up (replaces nParam1)
    int     nParam2;	            // unused, set to zero
    double  dParam1;	            // unused, set to zero
    double  dParam2;	            // unused, set to zero
    char    szDesc[256];		    // The channel description, only 59 characters used
    int     nType;                  // The channel type - one of the TCT_ defines above
    int     nFlags;                 // The channel flags
    char    szTitle[TALK_CTITL_SZ]; // The suggested channel title
    char    szUnits[TALK_CUNIT_SZ]; // The channel units
    int     nCount;                 // Count of items for extended markers
    double  dScale;                 // Channel scale factor as for SON file
    double  dOffset;                // Channel scaling offset
    int     nTrig;                  // Trigger offset for AdcMark data
    int     nTrace;                 // Number of traces for AdcMark data
    double  dIRate;                 // Expected max item rate for events and markers
    double  dWRate;                 // Waveform sampling rate for waveform items
    double  dMax;                   // Expected max value for RealMark and RealWave
    double  dMin;                   // Expected min value for RealMark and RealWave
    int     nSpare[32];	            // unused, set to zero

    TalkerChanInfo()                // Constructor ensures memory is zeroed
    {                               //  and nSize and nCode values are correct
        memset(&nSize, 0, sizeof(TalkerChanInfo));
        nSize = sizeof(TalkerChanInfo);
        nCode = TKC_GETCHAN|TKC_RESPONSE_BIT;
    }
} TalkerChanInfo;

// These are definitions of the channel flag bits - options specific to a channel.
// Again, the flags value is the sum of all required bits.
#define TCF_DELETEBAD       0x01    // Delete badly timed items rather than patching the time
#define TCF_S2TIMED         0x02    // Spike2 to generate all item time information
#define TCF_MYTIME          0x04    // Spike2 to trust event and marker times
#define TCF_MYRATE          0x08    // Spike2 to trust waveform sampling rates
#define TCF_LCLOCK          0x10    // Local performance-clock based time compensation

///////////////////////////////////////////////////////////////////////////////
//
// Spike2-based configuration dialog stuff
//
///////////////////////////////////////////////////////////////////////////////
//
// The TalkerDlgInfo structure holds information about the talker configuration
//  dialog. Sent by a talker to Spike2 in response to a DLGINFO request, so we
//  can initialise the nCode value automatically as well as nSize.
typedef struct TalkerDlgInfo
{
    int     nSize;                  // Size of this structure
    int     nCode;
    int     nItems;                 // The number of dialog items, replaces nParam1
    int     nParam2;	            // unused, set to zero
    double  dWide;	                // Dialog width, replaces dParam1
    double  dHigh;	                // Dialog height, replaces dParam2
    char    szTitle[256];		    // The dialog title, not more than 60 chars please
    int     nSpare[32];	            // unused, set to zero

    TalkerDlgInfo()                 // Constructor ensures memory is zeroed
    {                               //  and nSize and nCode values are correct
        memset(&nSize, 0, sizeof(TalkerDlgInfo));
        nSize = sizeof(TalkerDlgInfo);
        nCode = TKC_DLGINFO|TKC_RESPONSE_BIT;
    }
} TalkerDlgInfo;

// The TalkerDlgItem structure holds information about a configuration dialog
//  item. Sent by a talker to Spike2 in response to a DLGITEM request, so we
//  can initialise the nCode value automatically as well as nSize.
typedef struct TalkerDlgItem
{
    int     nSize;                  // Size of this structure
    int     nCode;
    int     nItem;                  // The dialog item number from 0 to nItems-1, replaces nParam1
    int     nType;	                // The item type code (see below), replaces nParam2
    double  dX;	                    // Item x position or 0 for default layout (was dParam1)
    double  dY;	                    // Item y position or 0 for default layout (was dParam2)
    char    szText[256];		    // The prompt string for the item, following | then tooltip is optional
    double  dWide;                  // Item width in dialog units.
    double  dHigh;                  // Item height for group boxes only.
    double  dLo;                    // Item value limits for reals and integers.
    double  dHi;
    double  dSpin;                  // Spinner value or zero for no spinner.
    int     nPre;                   // Precision for real items & max chars for string (0 for don't care).
    char    szList[1024];           // Selector list - items separated by | char. Required for list type.
    char    szLegal[256];           // Legal characters for string type, leave blank for all legal.
    int     nSpare[32];	            // unused, set to zero

    TalkerDlgItem()                 // Constructor ensures memory is zeroed
    {                               //  and nSize and nCode values are correct
        memset(&nSize, 0, sizeof(TalkerDlgItem));
        nSize = sizeof(TalkerDlgItem);
        nCode = TKC_DLGITEM|TKC_RESPONSE_BIT;
    }
} TalkerDlgItem;

// The definitions of the dialog item types
#define TDT_TEXT    0               // Static text
#define TDT_GROUP   1               // Static group-box
#define TDT_CHECK   2               // Check box
#define TDT_INT     3               // Integer
#define TDT_LIST    4               // 1 of n in a list
#define TDT_REAL    5               // Real
#define TDT_STRING  6               // String


///////////////////////////////////////////////////////////////////////////////
//
// The TalkerDriftInfo structure holds information about the talker drift
//  compensation to be used. Sent by a talker to Spike2 in response to a
//  DRIFTINFO request, so we can initialise the nCode value automatically
//  as well as nSize. We arrange for the initial values to be such that
//  would cause Spike2 to use default values.
typedef struct TalkerDriftInfo
{
    int     nSize;                  // Size of this structure
    int     nCode;
    int     nFlags;                 // Flags to select drift compensation options
    int     nDrBf;                  // Drift buffer size, -1 for default, 0 for all points
    double  dSDDump;	            // SD threshold for difference value to be ignored completely, or zero
    double  dSDUse; 	            // SD threshold for difference value to be used, or zero
    char    szParam[256];		    // the string parameter is unused
    int     nDiffAvg;               // Number of points to average into running time difference
    int     nSlopeAcc;	            // Number of points needed for a slope measurement, or zero
    int     nSlopeAvg;              // Number of points to average into slope before use, or zero
    int     nSpare[32];	            // unused, set to zero

    TalkerDriftInfo()               // Constructor ensures memory is zeroed
    {                               //  and nSize and nCode values are correct
        memset(&nSize, 0, sizeof(TalkerDriftInfo));
        nSize = sizeof(TalkerDriftInfo);
        nCode = TKC_DRIFTINFO|TKC_RESPONSE_BIT;
        nDrBf = -1;                 // Set values for default behaviour
    }
} TalkerDriftInfo;

///////////////////////////////////////////////////////////////////////////////
//
// Talker channel data stuff
//
///////////////////////////////////////////////////////////////////////////////
//
// The TalkerData structure is based on TalkPacket and sits at the start of all
//  channel (or keyboard) data sent by a talker to Spike2. For most types of data
//  this header is followed by structures as defined below (some of these varying
//  in size with different channel arrangements).
// For Adc data it is followed by a simple array of shorts, while for RealWave
//  data it is followed by an array of doubles - in both of these cases the dStart
//  value is the only timing info.
// For Event data it is followed by an array of doubles holding the event times
//  in seconds.
//
// NOTE WELL these structures don't have constructors to clear them because you
//  will always have to allocate them (or some such) as the overall packet size
//  varies so you MUST clear them yourself as well as setting nSize and nCode
//  correctly.
//
typedef struct TalkerData
{
    int     nSize;                  // Total size of the data packet, not just this structure
    int     nCode;                  // Will be the TALKERDATA code - no response bit
    int     nChan;                  // Channel number from 0 up (replaces nParam1)
    int     nItems;                 // Number of data items (replaces nParam2)
    double  dStart;                 // Time (or time offset) for first item (replaces dParam1)
    double  dNow;                   // Time at which the data packet was sent (replaces dParam2)
    int     nFlags;                 // TDF_ flag bits set to indicate various situations
    int     nItemSize;              // The size of the data items, in bytes - for checking
    int     nSpare[8];	            // unused, set to zero
} TalkerData;

typedef struct TalkerMData
{
    int     nSize;                  // Total size of the data packet, not just this structure
    int     nCode;                  // Will be the TALKERMDATA code - no response bit
    int     nBlocks;                // Number of channel data items (replaces nParam1)
    int     nFlags;                 // Flag bits set to indicate various situations (replaces nParam2)
    double  dNow;                   // Time at which the data packet was sent (replaces dParam1)
    double  dParam2;                // Currently unused
    int     nSpare[8];	            // unused, set to zero
} TalkerMData;

typedef struct TalkerMChan
{
    int     nChan;                  // Channel number from 0 up
    int     nFlags;                 // TDF_ flag bits set to indicate various situations
    int     nItems;                 // Number of data items
    int     nItemSize;              // The size of the data items, in bytes - for checking
    double  dStart;                 // Time (or time offset) for first item
    int     nSpare[4];	            // unused, set to zero
} TalkerMChan;

// These are the flag bits for the talker data flags, either in TalkerData or TalkerMChan
#define TDF_CONTIG      0x01        // Waveform packet contiguous with the previous packet
#define TDF_FLUSH       0x02        // Waveform packet is last for channel or has gap following
#define TDF_RISING      0x04        // In first Level packet, indicates first transition rising

// These are the structures defining the various types of non-trivial data. Note that though
//  the structures are of a fixed size, the size of actual data items can vary for all types
//  other than the simple marker as the extra data points are variable.
typedef struct TalkDataMarker
{
    double  dTime;
    long    lMark;
} TalkDataMarker;

typedef struct TalkDataRealMark
{
    double  dTime;
    long    lMark;
    double  adVals[64];
} TalkDataRealMark;

typedef struct TalkDataTextMark
{
    double  dTime;
    long    lMark;
    char    szText[80];
} TalkDataTextMark;

typedef struct TalkDataAdcMark
{
    double  dTime;
    long    lMark;
    short   asVals[1024];
} TalkDataAdcMark;

#pragma pack()
#endif